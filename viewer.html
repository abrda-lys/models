<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="icon" href="https://storage.yandexcloud.net/mymodels/favicon.ico" type="image/x-icon"/>
  <title>–ü—Ä–æ—Å–º–æ—Ç—Ä –º–æ–¥–µ–ª–∏ —Å –∏–∑–º–µ—Ä–µ–Ω–∏—è–º–∏</title>
  <style>
    /* –û—Å–Ω–æ–≤–Ω—ã–µ —Å—Ç–∏–ª–∏ –æ—Å—Ç–∞—é—Ç—Å—è –ø—Ä–µ–∂–Ω–∏–º–∏ */
    body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      background: url('background.jpg') no-repeat center center fixed;
      background-size: cover;
      font-family: Arial, sans-serif;
    }

    model-viewer {
      width: 80%;
      height: 80vh;
      background: white;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
      position: relative;
    }

    /* –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ —Å—Ç–∏–ª–∏ –¥–ª—è –∏–∑–º–µ—Ä–µ–Ω–∏—è */
    .measure-point {
      position: absolute;
      width: 10px;
      height: 10px;
      background: red;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
      pointer-events: none;
    }

    .measure-line-3d {
      position: absolute;
      background: rgba(255, 0, 0, 0.7);
      transform-origin: 0 0;
      z-index: 9;
      pointer-events: none;
    }

    .measure-label {
      position: absolute;
      background: rgba(255, 255, 255, 0.9);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      color: #333;
      z-index: 11;
      pointer-events: none;
      border: 1px solid #ccc;
      transform: translate(-50%, -100%);
    }

    .measure-controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 5px;
      display: none;
      z-index: 20;
    }

    .scale-input {
      margin: 10px 0;
      display: flex;
      align-items: center;
    }

    .scale-input label {
      margin-right: 10px;
      font-size: 14px;
    }

    .scale-input input {
      width: 80px;
      padding: 5px;
    }

    /* –û—Å—Ç–∞–ª—å–Ω—ã–µ —Å—Ç–∏–ª–∏ –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π */
    /* ... */
  </style>
  <script type="module" src="https://unpkg.com/@google/model-viewer@latest/dist/model-viewer.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
  <model-viewer id="modelViewer"
    poster="https://storage.yandexcloud.net/mymodels/label_1.png"
    ar
    ar-modes="webxr scene-viewer quick-look"
    camera-controls
    shadow-intensity="1">
    <div class="description">
      <strong>–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:</strong>
      <span id="descriptionText">–ó–∞–≥—Ä—É–∑–∫–∞ –æ–ø–∏—Å–∞–Ω–∏—è...</span>
    </div>
  </model-viewer>

  <div class="controls">
    <button class="arrow-button" onclick="rotate(-90)">‚¨ÖÔ∏è</button>
    <button class="arrow-button" onclick="setTopView()">‚¨áÔ∏è</button>
    <button class="arrow-button" onclick="rotate(90)">‚û°Ô∏è</button>
    <button class="measure-button" id="measureButton" onclick="toggleMeasureMode()">üìè</button>
  </div>

  <div class="measure-controls" id="measureControls">
    <div class="scale-input">
      <label>–ú–∞—Å—à—Ç–∞–± (–º–º/–µ–¥):</label>
      <input type="number" id="scaleInput" value="1" min="0.001" step="0.001">
    </div>
    <button onclick="clearMeasurements()">–û—á–∏—Å—Ç–∏—Ç—å</button>
    <button onclick="toggleMeasureMode()">–ó–∞–∫—Ä—ã—Ç—å</button>
  </div>

  <button class="projects-button" onclick="location.href='index.html'">
    –ü–†–û–ï–ö–¢–´
  </button>

  <script>
    let currentAzimuth = 0;
    let measureMode = false;
    let measurementPoints = [];
    let scaleFactor = 1;
    let scene = null;
    let modelViewer = null;
    let measureElements = [];

    document.addEventListener("DOMContentLoaded", async () => {
      modelViewer = document.getElementById("modelViewer");
      
      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Three.js —Å—Ü–µ–Ω—ã –¥–ª—è —Ç–æ—á–Ω—ã—Ö –∏–∑–º–µ—Ä–µ–Ω–∏–π
      await initThreeJS();
      
      // –ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏
      const params = new URLSearchParams(window.location.search);
      const modelUrl = params.get("model");

      if (modelUrl) {
        modelViewer.src = modelUrl;

        // –ó–∞–≥—Ä—É–∑–∫–∞ –æ–ø–∏—Å–∞–Ω–∏—è –º–æ–¥–µ–ª–∏
        fetch("https://storage.yandexcloud.net/mymodels/models.txt")
          .then(response => response.text())
          .then(text => {
            const lines = text.split("\n");
            let descriptionFound = false;

            for (const line of lines) {
              const parts = line.split(",");

              if (parts.length >= 3) {
                const name = parts[0];
                const url = parts[1];
                const description = parts.slice(2).join(",");

                if (url.trim() === modelUrl) {
                  document.getElementById("descriptionText").textContent = description.trim() || "–û–ø–∏—Å–∞–Ω–∏–µ –º–æ–¥–µ–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.";
                  descriptionFound = true;
                  break;
                }
              }
            }

            if (!descriptionFound) {
              document.getElementById("descriptionText").textContent = "–û–ø–∏—Å–∞–Ω–∏–µ –º–æ–¥–µ–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.";
            }
          })
          .catch(err => {
            console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –æ–ø–∏—Å–∞–Ω–∏—è:", err);
            document.getElementById("descriptionText").textContent = "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –æ–ø–∏—Å–∞–Ω–∏—è.";
          });
      } else {
        alert("–û—à–∏–±–∫–∞: URL –º–æ–¥–µ–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω!");
      }
    });

    async function initThreeJS() {
      // –ü–æ–ª—É—á–∞–µ–º Three.js —Å—Ü–µ–Ω—É –∏–∑ model-viewer
      await customElements.whenDefined('model-viewer');
      scene = modelViewer.querySelector('three-scene');
      
      // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞
      window.addEventListener('resize', () => {
        if (measureMode) updateMeasurementVisuals();
      });
    }

    function rotate(degrees) {
      currentAzimuth = (currentAzimuth + degrees + 360) % 360;
      modelViewer.cameraOrbit = `${currentAzimuth}deg 90deg auto`;
      if (measureMode) updateMeasurementVisuals();
    }

    function setTopView() {
      modelViewer.cameraOrbit = "90deg 0deg auto";
      if (measureMode) updateMeasurementVisuals();
    }

    function toggleMeasureMode() {
      measureMode = !measureMode;
      const measureControls = document.getElementById("measureControls");
      
      if (measureMode) {
        modelViewer.style.cursor = "crosshair";
        modelViewer.addEventListener("click", handleMeasurementClick);
        measureControls.style.display = "block";
        document.getElementById("measureButton").style.backgroundColor = "#4CAF50";
        
        // –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π –º–∞—Å—à—Ç–∞–± –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        const savedScale = localStorage.getItem('modelScale');
        if (savedScale) {
          document.getElementById("scaleInput").value = savedScale;
          scaleFactor = parseFloat(savedScale);
        }
      } else {
        modelViewer.style.cursor = "";
        modelViewer.removeEventListener("click", handleMeasurementClick);
        measureControls.style.display = "none";
        document.getElementById("measureButton").style.backgroundColor = "black";
      }
    }

    function handleMeasurementClick(event) {
      if (!measureMode || !scene) return;
      
      // –ü–æ–ª—É—á–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –∫–ª–∏–∫–∞ –≤ 3D –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ
      const hit = scene.hitTest(event.clientX, event.clientY);
      if (!hit) return;
      
      const point = hit.point;
      measurementPoints.push(point);
      
      // –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—é –∏–∑–º–µ—Ä–µ–Ω–∏–π
      updateMeasurementVisuals();
      
      // –ï—Å–ª–∏ —Ç–æ—á–µ–∫ –¥–≤–µ - –≤—ã—á–∏—Å–ª—è–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ
      if (measurementPoints.length === 2) {
        calculateDistance();
      } else if (measurementPoints.length > 2) {
        // –ù–∞—á–∏–Ω–∞–µ–º –Ω–æ–≤–æ–µ –∏–∑–º–µ—Ä–µ–Ω–∏–µ
        clearMeasurementVisuals();
        measurementPoints = [point];
      }
    }

    function calculateDistance() {
      const point1 = measurementPoints[0];
      const point2 = measurementPoints[1];
      
      // –í—ã—á–∏—Å–ª—è–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –≤ –º–∏—Ä–æ–≤—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö
      const dx = point2.x - point1.x;
      const dy = point2.y - point1.y;
      const dz = point2.z - point1.z;
      const worldDistance = Math.sqrt(dx*dx + dy*dy + dz*dz);
      
      // –ü–µ—Ä–µ–≤–æ–¥–∏–º –≤ –º–∏–ª–ª–∏–º–µ—Ç—Ä—ã —Å —É—á–µ—Ç–æ–º –º–∞—Å—à—Ç–∞–±–∞
      const realDistance = worldDistance * scaleFactor;
      
      // –°–æ–∑–¥–∞–µ–º –ø–æ–¥–ø–∏—Å—å —Å —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ–º
      createDistanceLabel(point1, point2, realDistance);
    }

    function updateMeasurementVisuals() {
      clearMeasurementVisuals();
      
      // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Ç–æ—á–∫–∏
      measurementPoints.forEach(point => {
        createMeasurePoint(point);
      });
      
      // –ï—Å–ª–∏ –µ—Å—Ç—å –¥–≤–µ —Ç–æ—á–∫–∏ - —Ä–∏—Å—É–µ–º –ª–∏–Ω–∏—é
      if (measurementPoints.length === 2) {
        createMeasureLine(measurementPoints[0], measurementPoints[1]);
      }
    }

    function createMeasurePoint(point3d) {
      const screenPoint = worldToScreen(point3d);
      if (!screenPoint) return;
      
      const pointElement = document.createElement("div");
      pointElement.className = "measure-point";
      pointElement.style.left = `${screenPoint.x}px`;
      pointElement.style.top = `${screenPoint.y}px`;
      
      modelViewer.appendChild(pointElement);
      measureElements.push(pointElement);
    }

    function createMeasureLine(point1, point2) {
      const screenPoint1 = worldToScreen(point1);
      const screenPoint2 = worldToScreen(point2);
      if (!screenPoint1 || !screenPoint2) return;
      
      const dx = screenPoint2.x - screenPoint1.x;
      const dy = screenPoint2.y - screenPoint1.y;
      const length = Math.sqrt(dx*dx + dy*dy);
      const angle = Math.atan2(dy, dx) * 180 / Math.PI;
      
      const lineElement = document.createElement("div");
      lineElement.className = "measure-line-3d";
      lineElement.style.width = `${length}px`;
      lineElement.style.left = `${screenPoint1.x}px`;
      lineElement.style.top = `${screenPoint1.y}px`;
      lineElement.style.transform = `rotate(${angle}deg)`;
      
      modelViewer.appendChild(lineElement);
      measureElements.push(lineElement);
    }

    function createDistanceLabel(point1, point2, distance) {
      const midpoint = {
        x: (point1.x + point2.x) / 2,
        y: (point1.y + point2.y) / 2,
        z: (point1.z + point2.z) / 2
      };
      
      const screenPoint = worldToScreen(midpoint);
      if (!screenPoint) return;
      
      const labelElement = document.createElement("div");
      labelElement.className = "measure-label";
      labelElement.textContent = `${distance.toFixed(2)} –º–º`;
      labelElement.style.left = `${screenPoint.x}px`;
      labelElement.style.top = `${screenPoint.y}px`;
      
      modelViewer.appendChild(labelElement);
      measureElements.push(labelElement);
    }

    function worldToScreen(point3d) {
      if (!scene || !scene.camera) return null;
      
      const camera = scene.camera;
      const width = modelViewer.clientWidth;
      const height = modelViewer.clientHeight;
      
      // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –º–∏—Ä–æ–≤—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ —ç–∫—Ä–∞–Ω–Ω—ã–µ
      const vector = new THREE.Vector3(point3d.x, point3d.y, point3d.z);
      vector.project(camera);
      
      const x = (vector.x * 0.5 + 0.5) * width;
      const y = -(vector.y * 0.5 - 0.5) * height;
      
      return { x, y };
    }

    function clearMeasurementVisuals() {
      measureElements.forEach(el => el.remove());
      measureElements = [];
    }

    function clearMeasurements() {
      clearMeasurementVisuals();
      measurementPoints = [];
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º –º–∞—Å—à—Ç–∞–± –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –∑–Ω–∞—á–µ–Ω–∏—è
    document.getElementById("scaleInput").addEventListener("change", function() {
      scaleFactor = parseFloat(this.value);
      localStorage.setItem('modelScale', scaleFactor);
      if (measurementPoints.length === 2) {
        clearMeasurementVisuals();
        updateMeasurementVisuals();
        calculateDistance();
      }
    });
  </script>
</body>
</html>
